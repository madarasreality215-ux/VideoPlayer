<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MediaTracker Pro - Your Ultimate Media Organizer</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#7c3aed">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="MediaTracker">
<link rel="apple-touch-icon" href="icons/icon-192x192.png">

<style>
  :root{
    --bg-light:#f3f4f6;
    --bg-dark:#0b1220;
    --card-light:#ffffff;
    --card-dark:#0f1724;
    --text-light:#0f1724;
    --text-dark:#e6eef9;
    --accent:#7c3aed;
    --accent-hover:#6d28d9;
    --muted:rgba(230,238,249,0.65);
    --root-folder-color: #10b981;
    --root-folder-hover: #34d399;
    --thumb-size:120px;
    --safe-area: env(safe-area-inset-bottom, 16px);
  }
  *{box-sizing:border-box}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:0;background:var(--bg-dark);color:var(--text-dark);transition:background .2s,color .2s}
  body.light{background:var(--bg-light);color:var(--text-light)}
  
  /* App container - COMPLETELY HIDDEN until authenticated */
  #appContainer{
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
  }
  #appContainer.authenticated{
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
  }
  
  /* Auth Screen Styles - ALWAYS SHOWN initially */
  #authScreen{
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-dark);
    color: var(--text-dark);
    transition: background .2s, color .2s;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10000;
  }
  body.light #authScreen{
    background: var(--bg-light);
    color: var(--text-light);
  }
  
  /* Hide auth screen when authenticated */
  #authScreen.authenticated{
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
  }

  .auth-container{
    width: 90%;
    max-width: 400px;
    padding: 40px 0;
  }
  .auth-card{
    background: var(--card-dark);
    padding: 32px;
    border-radius: 16px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.3);
    text-align: center;
  }
  body.light .auth-card{
    background: var(--card-light);
  }
  .auth-logo{
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--accent);
  }
  .auth-subtitle{
    color: var(--muted);
    margin-bottom: 32px;
    font-size: 16px;
  }
  .auth-form{
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .auth-form input{
    padding: 14px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.05);
    color: inherit;
    font-size: 16px;
    width: 100%;
  }
  body.light .auth-form input{
    border-color: rgba(0,0,0,0.1);
    background: rgba(0,0,0,0.05);
  }
  .auth-primary-btn{
    background: var(--accent);
    color: white;
    padding: 14px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    font-size: 16px;
    transition: background .2s;
    width: 100%;
  }
  .auth-primary-btn:hover{
    background: var(--accent-hover);
  }
  .auth-error{
    color: #ef4444;
    font-size: 14px;
    text-align: center;
    margin-top: 12px;
    display: none;
  }
  .auth-loading{
    display: none;
    text-align: center;
    margin-top: 16px;
  }

  /* FIXED FOLDER SECTION LAYOUT */
  .folder-creation {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 16px;
  }

  .folder-input-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .folder-input-row input {
    flex: 1;
    padding: 8px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.04);
    background: transparent;
    color: inherit;
    font-size: 14px;
    min-width: 0;
  }

  .folder-select-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  /* UPDATED: Consistent dropdown styling */
  .folder-select-row select,
  .url-downloader-btn,
  .cloud-storage-btn,
  .file-tools-btn {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.1);
    background: transparent;
    color: inherit;
    font-size: 14px;
    cursor: pointer;
    min-width: 0;
    transition: background 0.2s;
    appearance: none;
    background-image: url("data:image/svg+xml;charset=US-ASCII,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'><path fill='%23e6eef9' d='M2 0L0 2h4zm0 5L0 3h4z'/></svg>");
    background-repeat: no-repeat;
    background-position: right 12px center;
    background-size: 12px;
    padding-right: 35px;
  }

  .folder-select-row select:hover,
  .url-downloader-btn:hover,
  .cloud-storage-btn:hover,
  .file-tools-btn:hover {
    background: rgba(255,255,255,0.05);
  }

  body.light .folder-select-row select,
  body.light .url-downloader-btn,
  body.light .cloud-storage-btn,
  body.light .file-tools-btn {
    border-color: rgba(0,0,0,0.1);
    background-image: url("data:image/svg+xml;charset=US-ASCII,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'><path fill='%230f1724' d='M2 0L0 2h4zm0 5L0 3h4z'/></svg>");
  }

  .folder-select-row .btn {
    white-space: nowrap;
    flex-shrink: 0;
  }

  /* Mobile responsive for folder section */
  @media (max-width: 768px) {
    .folder-input-row,
    .folder-select-row {
      flex-direction: column;
    }
    
    .folder-input-row input,
    .folder-select-row select {
      width: 100%;
    }
  }

  /* ALL OTHER STYLES REMAIN EXACTLY THE SAME */
  header{display:flex;align-items:center;gap:12px;padding:12px 16px;background:var(--card-dark);position:sticky;top:0;z-index:100;}
  body.light header{background:var(--card-light)}
  h1{margin:0;font-size:18px}
  .controls{margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn{background:var(--accent);color:white;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:600;transition:background .2s}
  .btn:hover{background:var(--accent-hover)}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:inherit;cursor:pointer;transition:background .2s}
  .ghost:hover{background:rgba(255,255,255,0.05)}
  body.light .ghost{border-color:rgba(0,0,0,0.08)}
  body.light .ghost:hover{background:rgba(0,0,0,0.05)}
  
  .container{display:grid;grid-template-columns:320px 1fr;gap:16px;padding:16px;min-height:calc(100vh - 60px)}
  @media (max-width:960px){.container{grid-template-columns:1fr;}}
  @media (max-width:768px){.container{padding:12px;gap:12px;}}
  @media (max-width:480px){.container{padding:8px;gap:8px;}}
  
  .sidebar{background:var(--card-dark);padding:12px;border-radius:12px;min-height:60vh}
  body.light .sidebar{background:var(--card-light)}
  .main{background:var(--card-dark);padding:12px;border-radius:12px;min-height:60vh}
  body.light .main{background:var(--card-light)}

  .topbar{display:flex;gap:8px;align-items:center;margin-bottom:10px}
  input[type=search]{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:14px}
  body.light input[type=search]{border-color:rgba(0,0,0,0.08)}

  .folders{display:flex;flex-direction:column;gap:8px;max-height:40vh;overflow:auto;padding-right:6px}
  .folder{display:flex;align-items:center;gap:8px;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;transition:background .2s}
  .folder:hover{background:rgba(255,255,255,0.05)}
  .folder .name{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .folder .count{font-size:12px;color:var(--muted)}
  
  /* Folder collapse/expand styles */
  .folder-header{display:flex;align-items:center;gap:8px;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;transition:background-color 0.2s}
  .folder-header:hover{background:rgba(255,255,255,0.05)}
  .folder-header .icon{transition:transform 0.2s;width:16px;height:16px;display:flex;align-items:center;justify-content:center}
  .folder-header.collapsed .icon{transform:rotate(-90deg)}
  .folder-content{overflow:hidden;transition:max-height 0.3s ease-out}
  .folder-content.collapsed{max-height:0}
  .nested-folder{margin-left:20px;border-left:1px solid rgba(255,255,255,0.1);padding-left:8px}
  body.light .nested-folder{border-left-color:rgba(0,0,0,0.1)}

  .videoList{display:flex;flex-direction:column;gap:8px;max-height:40vh;overflow:auto}
  .vitem{display:flex;gap:10px;align-items:center;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;transition:background .2s}
  .vitem:hover{background:rgba(255,255,255,0.05)}
  .vitem.dragging{opacity:0.5;background:rgba(124,58,237,0.2);transform:scale(0.95)}
  .vitem.drop-target{background:rgba(124,58,237,0.1);border:2px dashed var(--accent)}
  .folder.drop-target{background:rgba(124,58,237,0.1);border:2px dashed var(--accent)}
  .thumb{width:var(--thumb-size);height:calc(var(--thumb-size)*0.6);background:#000;border-radius:8px;overflow:hidden;flex-shrink:0}
  .thumb img{width:100%;height:100%;object-fit:cover}
  .meta{flex:1;min-width:0}
  .meta h3{margin:0;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .meta p{margin:4px 0 0 0;font-size:12px;color:var(--muted)}

  .viewer video{width:100%;height:auto;max-height:70vh;background:#000;border-radius:8px}
  .fields{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .fields input,.fields textarea,.fields select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:14px;flex:1;min-width:150px}
  body.light .fields input,body.light .fields textarea,body.light .fields select{border-color:rgba(0,0,0,0.08)}
  .small{font-size:12px;color:var(--muted)}

  .folder-actions{display:flex;gap:8px;margin-top:8px}
  .collapse{opacity:0.8}
  .controls .btn-sm{padding:6px 8px;font-size:13px}

  /* Action Sections */
  .action-section{margin-top:16px;padding:12px;background:rgba(255,255,255,0.02);border-radius:8px;border:1px solid rgba(255,255,255,0.04)}
  body.light .action-section{background:rgba(0,0,0,0.02);border-color:rgba(0,0,0,0.08)}
  .action-section h3{margin:0 0 8px 0;font-size:14px;color:var(--accent)}
  .action-buttons{display:flex;flex-direction:column;gap:8px}
  .action-buttons .btn,.action-buttons .ghost{width:100%;justify-content:center;text-align:center}
  
  /* Mobile-specific styles - Enhanced for iOS/Android */
  .mobile-controls{display:none;position:fixed;bottom:0;left:0;right:0;background:var(--card-dark);padding:12px;border-top:1px solid rgba(255,255,255,0.1);z-index:100;padding-bottom: calc(12px + var(--safe-area))}
  body.light .mobile-controls{background:var(--card-light);border-top-color:rgba(0,0,0,0.1)}
  .mobile-controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  
  /* Media type indicators */
  .media-type-badge{background:var(--accent);color:white;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:600}
  .media-type-photo{background:#10b981}
  .media-type-video{background:#7c3aed}
  
  /* Add Media Buttons */
  .add-media-buttons{display:flex;gap:8px;margin-top:8px}
  .add-media-buttons .btn{flex:1;min-width:0}
  
  /* Firebase sync status */
  .sync-status{display:flex;align-items:center;gap:6px;font-size:12px;color:var(--muted);margin-top:8px}
  .sync-indicator{width:8px;height:8px;border-radius:50%;background:#10b981}
  .sync-indicator.syncing{background:#f59e0b;animation:pulse 1.5s infinite}
  .sync-indicator.error{background:#ef4444}
  @keyframes pulse{0%{opacity:1}50%{opacity:0.5}100%{opacity:1}}
  
  /* Upload Progress Styles */
  .upload-progress {margin-top: 12px; padding: 12px; background: rgba(255,255,255,0.02); border-radius: 8px; border: 1px solid rgba(255,255,255,0.04)}
  .progress-bar {width: 100%; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin-top: 8px}
  .progress-fill {height: 100%; background: var(--accent); transition: width 0.3s ease}
  .progress-text {font-size: 12px; color: var(--muted); margin-top: 4px}
  .duplicate-warning {background: rgba(245,158,11,0.1); border: 1px solid rgba(245,158,11,0.3); padding: 8px; border-radius: 6px; margin-top: 8px; font-size: 12px}
  
  /* Cloud Storage Styles - UPDATED */
  .cloud-storage-dropdown {position: relative; display: inline-block; width: 100%;}
  .cloud-storage-btn {width: 100%; padding: 10px; background: transparent; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: inherit; cursor: pointer; display: flex; align-items: center; justify-content: space-between; font-size: 14px;}
  .cloud-storage-btn:hover {background: rgba(255,255,255,0.05);}
  .cloud-dropdown-content {display: none; position: absolute; top: 100%; left: 0; right: 0; background: var(--card-dark); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 8px; z-index: 1000; margin-top: 4px;}
  .cloud-dropdown-content.show {display: block;}
  .cloud-option {padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: background 0.2s;}
  .cloud-option:hover {background: rgba(255,255,255,0.05);}
  .cloud-option.mega {color: #D90007;}
  .cloud-option.local {color: #10b981;}
  .cloud-browser {margin-top: 12px; padding: 12px; background: rgba(255,255,255,0.02); border-radius: 8px; border: 1px solid rgba(255,255,255,0.04); display: none;}
  .cloud-browser.show {display: block;}
  .cloud-folder {padding: 8px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px; margin-bottom: 4px;}
  .cloud-folder:hover {background: rgba(255,255,255,0.05);}
  .cloud-file {padding: 8px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px; margin-bottom: 4px;}
  .cloud-file:hover {background: rgba(255,255,255,0.05);}
  .cloud-back {padding: 8px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px; margin-bottom: 8px; color: var(--accent);}
  .cloud-back:hover {background: rgba(255,255,255,0.05);}

  /* URL Downloader - RESTRUCTURED */
  .url-downloader-section {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .url-input-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .url-input-group input {
    width: 100%;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.05);
    color: inherit;
    font-size: 14px;
  }
  
  .url-downloader-dropdown {
    position: relative;
    display: inline-block;
    width: 100%;
  }
  
  .url-downloader-btn {
    width: 100%;
    padding: 10px;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: inherit;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 14px;
  }
  
  .url-downloader-btn:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .url-downloader-content {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: var(--card-dark);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 8px;
    z-index: 1000;
    margin-top: 4px;
  }
  
  .url-downloader-content.show {
    display: block;
  }
  
  .url-option {
    padding: 10px;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background 0.2s;
  }
  
  .url-option:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .url-download-btn {
    width: 100%;
    padding: 10px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s;
  }
  
  .url-download-btn:hover {
    background: var(--accent-hover);
  }

  /* File Tools Dropdown Styles */
  .file-tools-dropdown {position: relative; display: inline-block; width: 100%;}
  .file-tools-btn {width: 100%; padding: 10px; background: transparent; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: inherit; cursor: pointer; display: flex; align-items: center; justify-content: space-between; font-size: 14px;}
  .file-tools-btn:hover {background: rgba(255,255,255,0.05);}
  .file-tools-content {display: none; position: absolute; top: 100%; left: 0; right: 0; background: var(--card-dark); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 8px; z-index: 1000; margin-top: 4px;}
  .file-tools-content.show {display: block;}
  .file-tool-option {padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px; transition:background 0.2s;}
  .file-tool-option:hover {background: rgba(255,255,255,0.05);}

  /* Custom Modal Styles */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  }
  .modal-overlay.show {
    display: flex;
  }
  .modal {
    background: var(--card-dark);
    border-radius: 12px;
    padding: 24px;
    max-width: 400px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }
  body.light .modal {
    background: var(--card-light);
  }
  .modal h3 {
    margin: 0 0 16px 0;
    color: var(--accent);
  }
  .modal-buttons {
    display: flex;
    gap: 12px;
    margin-top: 20px;
    justify-content: flex-end;
  }
  .modal-buttons .btn {
    min-width: 80px;
  }

  /* Enhanced Video Player */
  .video-player-container {
    position: relative;
    background: #000;
    border-radius: 8px;
    overflow: hidden;
  }
  .video-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0,0,0,0.7));
    padding: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    opacity: 0;
    transition: opacity 0.3s;
  }
  .video-player-container:hover .video-controls {
    opacity: 1;
  }
  .control-btn {
    background: none;
    border: none;
    color: white;
    font-size: 20px;
    cursor: pointer;
    padding: 8px;
  }
  .progress-container {
    flex: 1;
    height: 4px;
    background: rgba(255,255,255,0.3);
    border-radius: 2px;
    cursor: pointer;
    position: relative;
  }
  .progress-bar {
    height: 100%;
    background: var(--accent);
    border-radius: 2px;
    width: 0%;
  }
  .time-display {
    color: white;
    font-size: 14px;
    min-width: 100px;
    text-align: center;
  }

  /* File Conversion Tools */
  .conversion-tools {
    margin-top: 12px;
    padding: 12px;
    background: rgba(255,255,255,0.02);
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.04);
  }
  .conversion-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-top: 8px;
  }
  .conversion-option {
    padding: 10px;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    text-align: center;
    cursor: pointer;
    transition: background 0.2s;
  }
  .conversion-option:hover {
    background: rgba(255,255,255,0.05);
  }

  /* Install Prompt */
  .install-prompt {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--accent);
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    display: none;
    align-items: center;
    gap: 12px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  .install-prompt.show {
    display: flex;
  }
  .install-close {
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 18px;
  }

  /* Context Menu */
  .context-menu {
    position: fixed;
    background: var(--card-dark);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 8px;
    z-index: 1000;
    display: none;
    min-width: 150px;
  }
  .context-menu.show {
    display: block;
  }
  .context-item {
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s;
  }
  .context-item:hover {
    background: rgba(255,255,255,0.05);
  }
  .context-item.danger {
    color: #ef4444;
  }

  /* Video Popup Overlay - Google Drive Style */
  .video-popup {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  /* When visible */
  .video-popup.show {
    display: flex;
    opacity: 1;
  }

  /* Popup content area */
  .video-popup-content {
    position: relative;
    background: #000;
    padding: 0;
    border-radius: 12px;
    max-width: 90%;
    max-height: 90%;
    width: auto;
    height: auto;
    box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
    transform: scale(0.9);
    transition: transform 0.3s ease;
  }

  /* Scale up slightly when visible */
  .video-popup.show .video-popup-content {
    transform: scale(1);
  }

  /* Video inside popup */
  .video-popup-content video {
    width: 100%;
    height: auto;
    max-height: 85vh;
    border-radius: 12px;
    display: block;
  }

  /* Close button */
  .close-popup {
    position: absolute;
    top: -40px;
    right: 0;
    color: #fff;
    font-size: 36px;
    font-weight: bold;
    cursor: pointer;
    transition: color 0.2s;
    z-index: 10000;
    background: none;
    border: none;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .close-popup:hover {
    color: #ff6b6b;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
  }

  /* Root Folder Special Styling */
  .root-folder-option {
    color: var(--root-folder-color);
    font-weight: 600;
    border-left: 3px solid var(--root-folder-color);
    padding-left: 12px;
    margin: 8px 0;
    transition: all 0.3s ease;
  }

  .root-folder-option:hover {
    color: var(--root-folder-hover);
    background: rgba(16, 185, 129, 0.1);
    border-left-color: var(--root-folder-hover);
  }

  /* Local Folder Import Styles */
  .local-folder-input {
    display: none;
  }

  /* NEW: Folder Delete Button Styles */
  .folder-delete-btn {
    background: none;
    border: none;
    color: #ef4444;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    font-size: 12px;
    opacity: 0.7;
    transition: all 0.2s;
  }

  .folder-delete-btn:hover {
    background: rgba(239, 68, 68, 0.1);
    opacity: 1;
    transform: scale(1.1);
  }

  /* Twitter Video Preview Styles */
  .twitter-preview {
    margin-top: 12px;
    padding: 12px;
    background: rgba(255,255,255,0.02);
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.04);
    display: none;
  }
  
  .twitter-preview.show {
    display: block;
  }
  
  .twitter-video-preview {
    width: 100%;
    max-width: 400px;
    border-radius: 8px;
    margin-bottom: 8px;
  }
  
  .twitter-video-info {
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 8px;
  }
  
  .twitter-download-options {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .twitter-download-btn {
    padding: 8px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s;
  }
  
  .twitter-download-btn:hover {
    background: var(--accent-hover);
  }

  /* Drag and Drop Styles */
  .vitem.drag-over {
    background: rgba(124, 58, 237, 0.2);
    border: 2px dashed var(--accent);
  }
  
  .folder-item.drag-over {
    background: rgba(124, 58, 237, 0.2);
    border: 2px dashed var(--accent);
  }
  
  .drag-indicator {
    position: fixed;
    background: var(--accent);
    color: white;
    padding: 8px 12px;
    border-radius: 20px;
    z-index: 10000;
    pointer-events: none;
    font-size: 14px;
    display: none;
  }

  /* Enhanced mobile styles */
  @media (max-width:768px){
    .container{min-height:calc(100vh - 120px);margin-bottom:70px}
    .mobile-controls{display:block}
    .desktop-controls{display:none}
    .folders, .videoList{max-height:30vh}
    .fields{flex-direction:column}
    .fields input,.fields textarea,.fields select{min-width:auto}
    .viewer video{max-height:50vh}
    .thumb{width:80px;height:48px}
    
    /* Better touch targets for mobile */
    .vitem, .folder, .folder-header{padding:12px 10px;min-height:48px}
    .btn, .ghost{min-height:44px;display:flex;align-items:center;justify-content:center}
    
    /* Improved mobile header */
    header{padding:10px 12px}
    h1{font-size:16px}
    
    /* Better mobile controls layout */
    .mobile-controls-grid{grid-template-columns:1fr 1fr;gap:8px}
    
    /* Mobile auth styles */
    .auth-card{padding:24px;margin:20px}
    .auth-container{padding:20px 0}

    /* Mobile video controls */
    .video-controls {
      opacity: 1;
      padding: 12px;
    }
    .control-btn {
      font-size: 18px;
      padding: 6px;
    }

    /* Mobile conversion tools */
    .conversion-options {
      grid-template-columns: 1fr;
    }

    /* Mobile popup adjustments */
    .video-popup-content {
      max-width: 95%;
      max-height: 80%;
    }
    .close-popup {
      top: -35px;
      right: -5px;
      font-size: 30px;
    }

    /* Mobile folder actions */
    .folder-actions-menu {
      gap: 2px;
    }

    /* Mobile Twitter preview */
    .twitter-video-preview {
      max-width: 100%;
    }
  }
  
  @media (max-width:480px){
    header{padding:8px 12px}
    .container{padding-bottom:80px}
    .sidebar, .main{padding:8px}
    .mobile-controls{padding:10px}
    .mobile-controls-grid{grid-template-columns:1fr 1fr;gap:6px}
    .action-buttons .btn,.action-buttons .ghost{padding:10px;font-size:14px}
    
    /* Stack add media buttons on very small screens */
    .add-media-buttons{flex-direction:column}
    
    /* Mobile auth styles */
    .auth-card{padding:20px 16px}

    /* Mobile install prompt */
    .install-prompt {
      bottom: 80px;
      right: 12px;
      left: 12px;
    }

    /* Mobile popup adjustments */
    .video-popup-content {
      max-width: 98%;
      max-height: 75%;
    }
    .close-popup {
      top: -30px;
      right: -5px;
      font-size: 28px;
    }
  }

  /* Tablet-specific improvements */
  @media (min-width:769px) and (max-width:1024px){
    .container{grid-template-columns:280px 1fr;gap:12px}
    .thumb{width:100px;height:60px}
  }

  /* Touch-friendly improvements for all touch devices */
  @media (hover: none) and (pointer: coarse){
    .vitem, .folder, .folder-header{padding:14px 10px;min-height:52px}
    .btn, .ghost{min-height:48px;display:flex;align-items:center;justify-content:center;font-size:15px}
    input, textarea, select{font-size:16px;padding:12px 10px}
    
    /* Better touch feedback */
    .vitem:active, .folder:active, .folder-header:active{background:rgba(124,58,237,0.2)}

    /* Always show video controls on touch devices */
    .video-controls {
      opacity: 1;
    }
  }

  /* iOS Safari specific fixes */
  @supports (-webkit-touch-callout: none) {
    .mobile-controls{padding-bottom: max(12px, var(--safe-area))}
    .container{min-height: calc(100vh - 60px - env(safe-area-inset-bottom))}
    
    /* iPhone 12 Pro Max specific optimizations */
    @media (device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) {
      .container{min-height: calc(100vh - 60px - 34px)}
      .mobile-controls{padding-bottom: max(12px, 34px)}
    }
  }

  /* Nested folder styles */
  .folder-tree {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  
  .folder-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  .folder-item:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .folder-item.active {
    background: rgba(124,58,237,0.2);
  }
  
  .folder-children {
    margin-left: 20px;
    border-left: 1px solid rgba(255,255,255,0.1);
    padding-left: 8px;
  }
  
  .folder-actions-menu {
    display: flex;
    gap: 4px;
    margin-left: auto;
  }
  
  .folder-action-btn {
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    font-size: 12px;
  }
  
  .folder-action-btn:hover {
    background: rgba(255,255,255,0.1);
    color: var(--text-dark);
  }

  /* Ensure video controls are visible in popup */
  #popupVideo {
    width: 100%;
    height: auto;
  }

  /* Prevent body scroll when popup is open */
  body.popup-open {
    overflow: hidden;
  }
</style>
</head>
<body>
<!-- Authentication Screen (ALWAYS VISIBLE initially) -->
<div id="authScreen">
  <div class="auth-container">
    <div class="auth-card">
      <div class="auth-logo">üì± MediaTracker Pro</div>
      <div class="auth-subtitle" id="authSubtitle">Sign in to your media library üìÇ</div>
      
      <div id="authError" class="auth-error"></div>
      <div id="authLoading" class="auth-loading">
        <div class="small">Loading...</div>
      </div>
      
      <form id="authForm" class="auth-form">
        <input type="email" id="authEmail" placeholder="Email" required>
        <input type="password" id="authPassword" placeholder="Password" required>
        <button type="submit" id="authSubmit" class="auth-primary-btn">Sign In</button>
      </form>
    </div>
  </div>
</div>

<!-- Main App (COMPLETELY HIDDEN until authenticated) -->
<div id="appContainer">
  <header>
    <h1>üì± MediaTracker Pro</h1>
    <div class="controls desktop-controls">
      <a href="stats.html" class="ghost" style="text-decoration: none; color: inherit; display: flex; align-items: center; gap: 4px;">
        üìä Stats
      </a>
      <button id="signOutBtn" class="ghost">üö™ Sign Out</button>
    </div>
  </header>

  <div class="container">
    <aside class="sidebar">
      <div class="topbar">
        <button id="syncBtn" class="btn" style="flex:1">üîÑ Sync Now</button>
      </div>

      <!-- FIXED FOLDER CREATION SECTION -->
      <div class="folder-creation">
        <div class="folder-input-row">
          <input id="newFolderName" placeholder="New folder name">
        </div>
        <div class="folder-select-row">
          <!-- UPDATED: Consistent dropdown styling -->
          <select id="parentFolderSelect">
            <option value="">üè† Main Library (Home)</option>
          </select>
          <button id="addFolderBtn" class="btn btn-sm">üìÅ Add</button>
        </div>
      </div>

      <div class="folders" id="folders">
        <!-- Folders will be populated here -->
      </div>

      <!-- Add Media Section -->
      <div class="action-section">
        <h3>‚ûï Add Media</h3>
        <div class="add-media-buttons">
          <label style="display:block;flex:1">
            <input id="fileInputVideo" type="file" accept="video/*" multiple style="display:none">
            <button id="addVideoBtn" class="btn">üé• Add Videos</button>
          </label>
          <label style="display:block;flex:1">
            <input id="fileInputPhoto" type="file" accept="image/*" multiple style="display:none">
            <button id="addPhotoBtn" class="btn" style="background:#10b981">üì∑ Add Photos</button>
          </label>
        </div>
        <div class="small" style="text-align:center;margin-top:4px">Supports MP4, WebM, MOV, JPG, PNG, GIF</div>
      </div>

      <!-- Twitter/X Downloader Section - NO DROPDOWN -->
      <div class="action-section">
        <h3>üê¶ Twitter/X Downloader</h3>
        <div class="url-downloader-section">
          <!-- URL Input -->
          <div class="url-input-group">
            <input type="url" id="videoUrl" placeholder="Paste Twitter/X URL here">
          </div>
          
          <!-- Twitter Preview Section -->
          <div class="twitter-preview" id="twitterPreview">
            <video class="twitter-video-preview" id="twitterVideoPreview" controls></video>
            <div class="twitter-video-info" id="twitterVideoInfo"></div>
            <div class="twitter-download-options" id="twitterDownloadOptions"></div>
          </div>
          
          <!-- Download Button -->
          <button class="url-download-btn" id="downloadUrlBtn">Fetch Twitter Media</button>
        </div>
      </div>

      <!-- AUTO-DETECTING MULTI-PLATFORM DOWNLOADER -->
      <div class="action-section">
        <h3>üåê Multi-Platform Downloader</h3>
        <div class="url-downloader-section">
          <!-- URL Input -->
          <div class="url-input-group">
            <input type="url" id="multiPlatformUrl" placeholder="Paste any media URL (YouTube, Instagram, TikTok, etc.)">
          </div>
          
          <!-- Auto-Detected Platform Info -->
          <div class="url-input-group" id="platformInfo" style="display: none;">
            <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(124, 58, 237, 0.1); border-radius: 8px;">
              <span id="platformIcon" style="font-size: 16px;">üåê</span>
              <span id="platformName" style="font-size: 14px; font-weight: 500;">Platform</span>
              <span id="mediaType" style="margin-left: auto; padding: 2px 8px; background: var(--accent); color: white; border-radius: 12px; font-size: 12px;">Media</span>
            </div>
          </div>
          
          <!-- Preview Section -->
          <div class="twitter-preview" id="multiPlatformPreview">
            <div id="multiPlatformMediaContainer">
              <video class="twitter-video-preview" id="multiPlatformVideoPreview" controls style="display: none;"></video>
              <img class="twitter-video-preview" id="multiPlatformImagePreview" style="display: none; max-width: 100%; border-radius: 8px;">
              <div id="multiPlatformAudioPreview" style="display: none; text-align: center; padding: 20px;">
                <div style="font-size: 48px;">üéµ</div>
                <div style="font-size: 14px; color: var(--muted); margin-top: 8px;">Audio File</div>
              </div>
            </div>
            <div class="twitter-video-info" id="multiPlatformVideoInfo"></div>
            <div class="twitter-download-options" id="multiPlatformDownloadOptions"></div>
          </div>
          
          <!-- Action Buttons -->
          <div style="display: flex; gap: 8px;">
            <button class="url-download-btn" id="detectMediaBtn" style="flex: 2;">üîç Detect Media</button>
            <button class="ghost" id="clearUrlBtn" style="flex: 1;">Clear</button>
          </div>
          
          <!-- API Status -->
          <div class="sync-status" id="apiStatus" style="margin-top: 8px;">
            <div class="sync-indicator" id="apiIndicator"></div>
            <span id="apiStatusText">Ready to detect media</span>
          </div>
        </div>
      </div>

      <!-- Export/Import Section -->
      <div class="action-section">
        <h3>üì§ Export & Import</h3>
        <div class="action-buttons">
          <button class="btn" id="exportBtn">Export Library</button>
          <button class="ghost" id="importBtn">Import Library</button>
        </div>
      </div>

      <!-- Cloud Storage Section - UPDATED -->
      <div class="action-section">
        <h3>üìÇ Import & Cloud Storage</h3>
        <div class="cloud-storage-dropdown">
          <button class="cloud-storage-btn" id="cloudStorageBtn">
            <span>Select Import Source</span>
          </button>
          <div class="cloud-dropdown-content" id="cloudStorageDropdown">
            <!-- Local Folder Import Option -->
            <div class="cloud-option local" data-provider="local">
              <span>üíª</span>
              <span>Import Local Folder</span>
            </div>
            <!-- MEGA Option -->
            <div class="cloud-option mega" data-provider="mega">
              <span>üî¥</span>
              <span>MEGA Cloud Storage</span>
            </div>
          </div>
        </div>
        <!-- Hidden file input for folder selection -->
        <input type="file" id="localFolderInput" class="local-folder-input" webkitdirectory multiple>
      </div>

      <!-- File Tools Section -->
      <div class="action-section">
        <h3>üõ†Ô∏è File Tools</h3>
        <div class="file-tools-dropdown">
          <button class="file-tools-btn" id="fileToolsBtn">
            <span>Select File Tool</span>
          </button>
          <div class="file-tools-content" id="fileToolsDropdown">
            <div class="file-tool-option" data-tool="rename">
              <span>üìù</span>
              <span>Rename Files</span>
            </div>
            <div class="file-tool-option" data-tool="convert">
              <span>üîÑ</span>
              <span>Convert Format</span>
            </div>
            <div class="file-tool-option" data-tool="compress">
              <span>üóúÔ∏è</span>
              <span>Compress Video</span>
            </div>
            <div class="file-tool-option" data-tool="extract">
              <span>üéµ</span>
              <span>Extract Audio</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Sync Status -->
      <div class="sync-status">
        <div class="sync-indicator" id="syncIndicator"></div>
        <span id="syncStatusText">Ready to sync</span>
      </div>
    </aside>

    <main class="main">
      <div class="topbar">
        <input type="search" id="searchInput" placeholder="üîç Search videos...">
        <button id="sortBtn" class="ghost">üìÖ Sort: Newest</button>
      </div>
      <div class="videoList" id="videoList">
        <!-- Videos will be populated here -->
      </div>
      <div class="viewer" id="viewer" style="display:none">
        <!-- Video player will be shown here -->
      </div>
    </main>
  </div>

  <!-- Mobile Controls -->
  <div class="mobile-controls">
    <div class="mobile-controls-grid">
      <button id="mobileSyncBtn" class="btn">üîÑ Sync</button>
      <button id="mobileAddBtn" class="btn">‚ûï Add Media</button>
    </div>
  </div>
</div>

<!-- Video Popup Overlay -->
<div class="video-popup" id="videoPopup">
  <div class="video-popup-content">
    <button class="close-popup" id="closePopup">&times;</button>
    <video id="popupVideo" controls playsinline>
      Your browser does not support the video tag.
    </video>
  </div>
</div>

<!-- Drag Indicator -->
<div class="drag-indicator" id="dragIndicator">Drop to add to folder</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-storage-compat.js"></script>

<script>
  // Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyBH691ymS0uO7JejXC1MGFuhiIElD78UPY",
    authDomain: "personalplayer-c8d3b.firebaseapp.com",
    projectId: "personalplayer-c8d3b",
    storageBucket: "personalplayer-c8d3b.firebasestorage.app",
    messagingSenderId: "396785312809",
    appId: "1:396785312809:web:02290950ec22a13165a838",
    measurementId: "G-2Q8W3GJF1S"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();
  const storage = firebase.storage();

  // DOM elements
  const authScreen = document.getElementById('authScreen');
  const appContainer = document.getElementById('appContainer');
  const authForm = document.getElementById('authForm');
  const authEmail = document.getElementById('authEmail');
  const authPassword = document.getElementById('authPassword');
  const authSubmit = document.getElementById('authSubmit');
  const authError = document.getElementById('authError');
  const authLoading = document.getElementById('authLoading');
  const authSubtitle = document.getElementById('authSubtitle');
  const signOutBtn = document.getElementById('signOutBtn');
  const syncBtn = document.getElementById('syncBtn');
  const mobileSyncBtn = document.getElementById('mobileSyncBtn');
  const mobileAddBtn = document.getElementById('mobileAddBtn');
  const folders = document.getElementById('folders');
  const videoList = document.getElementById('videoList');
  const viewer = document.getElementById('viewer');
  const searchInput = document.getElementById('searchInput');
  const sortBtn = document.getElementById('sortBtn');
  const newFolderName = document.getElementById('newFolderName');
  const parentFolderSelect = document.getElementById('parentFolderSelect');
  const addFolderBtn = document.getElementById('addFolderBtn');
  const fileInputVideo = document.getElementById('fileInputVideo');
  const fileInputPhoto = document.getElementById('fileInputPhoto');
  const addVideoBtn = document.getElementById('addVideoBtn');
  const addPhotoBtn = document.getElementById('addPhotoBtn');
  const syncIndicator = document.getElementById('syncIndicator');
  const syncStatusText = document.getElementById('syncStatusText');

  // Video Popup Elements
  const videoPopup = document.getElementById('videoPopup');
  const popupVideo = document.getElementById('popupVideo');
  const closePopup = document.getElementById('closePopup');

  // Cloud Storage Elements
  const cloudStorageBtn = document.getElementById('cloudStorageBtn');
  const cloudStorageDropdown = document.getElementById('cloudStorageDropdown');

  // URL Downloader Elements - SIMPLIFIED
  const videoUrl = document.getElementById('videoUrl');
  const downloadUrlBtn = document.getElementById('downloadUrlBtn');
  const twitterPreview = document.getElementById('twitterPreview');
  const twitterVideoPreview = document.getElementById('twitterVideoPreview');
  const twitterVideoInfo = document.getElementById('twitterVideoInfo');
  const twitterDownloadOptions = document.getElementById('twitterDownloadOptions');

  // Multi-Platform Downloader Elements with Auto-Detection
  const multiPlatformUrl = document.getElementById('multiPlatformUrl');
  const detectMediaBtn = document.getElementById('detectMediaBtn');
  const clearUrlBtn = document.getElementById('clearUrlBtn');
  const multiPlatformPreview = document.getElementById('multiPlatformPreview');
  const multiPlatformVideoPreview = document.getElementById('multiPlatformVideoPreview');
  const multiPlatformImagePreview = document.getElementById('multiPlatformImagePreview');
  const multiPlatformAudioPreview = document.getElementById('multiPlatformAudioPreview');
  const multiPlatformVideoInfo = document.getElementById('multiPlatformVideoInfo');
  const multiPlatformDownloadOptions = document.getElementById('multiPlatformDownloadOptions');
  const platformInfo = document.getElementById('platformInfo');
  const platformIcon = document.getElementById('platformIcon');
  const platformName = document.getElementById('platformName');
  const mediaType = document.getElementById('mediaType');
  const apiIndicator = document.getElementById('apiIndicator');
  const apiStatusText = document.getElementById('apiStatusText');

  // Export/Import Elements
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');

  // File Tools Elements
  const fileToolsBtn = document.getElementById('fileToolsBtn');
  const fileToolsDropdown = document.getElementById('fileToolsDropdown');

  // Local Folder Import Element
  const localFolderInput = document.getElementById('localFolderInput');

  // Drag Indicator Element
  const dragIndicator = document.getElementById('dragIndicator');

  // App state
  let currentUser = null;
  let foldersData = {};
  let videosData = {};
  let currentFolder = null;
  let currentVideo = null;
  let sortOrder = 'newest';
  let draggedVideo = null;
  let isOnline = navigator.onLine;

  // Platform Detection Patterns
  const PLATFORM_PATTERNS = {
    youtube: {
      patterns: [
        /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/,
        /youtube\.com\/shorts\/([^"&?\/\s]{11})/
      ],
      name: 'YouTube',
      icon: 'üì∫',
      type: 'video'
    },
    instagram: {
      patterns: [
        /instagram\.com\/(?:p|reel|stories)\/([^\/?]+)/,
        /instagram\.com\/reel\/([^\/?]+)/
      ],
      name: 'Instagram',
      icon: 'üì∑',
      type: 'mixed'
    },
    tiktok: {
      patterns: [
        /tiktok\.com\/@[\w.]+\/video\/(\d+)/,
        /vm\.tiktok\.com\/([^\/]+)/,
        /vt\.tiktok\.com\/([^\/]+)/
      ],
      name: 'TikTok',
      icon: 'üéµ',
      type: 'video'
    },
    facebook: {
      patterns: [
        /facebook\.com\/([^\/]+\/videos\/(?:\d+)|watch\/\?v=(\d+))/,
        /fb\.watch\/([^\/]+)/
      ],
      name: 'Facebook',
      icon: 'üë§',
      type: 'video'
    },
    reddit: {
      patterns: [
        /reddit\.com\/r\/[\w]+\/comments\/([^\/]+)/
      ],
      name: 'Reddit',
      icon: 'üëæ',
      type: 'mixed'
    },
    pinterest: {
      patterns: [
        /pinterest\.(com|fr)\/pin\/(\d+)/
      ],
      name: 'Pinterest',
      icon: 'üìå',
      type: 'image'
    },
    dailymotion: {
      patterns: [
        /dailymotion\.com\/video\/([^_]+)/
      ],
      name: 'Dailymotion',
      icon: 'üé¨',
      type: 'video'
    },
    vimeo: {
      patterns: [
        /vimeo\.com\/(\d+)/
      ],
      name: 'Vimeo',
      icon: 'üé•',
      type: 'video'
    },
    twitch: {
      patterns: [
        /twitch\.tv\/[\w]+\/clip\/([^\/]+)/,
        /clips\.twitch\.tv\/([^\/]+)/
      ],
      name: 'Twitch',
      icon: 'üü£',
      type: 'video'
    },
    linkedin: {
      patterns: [
        /linkedin\.com\/posts\/[^\/]+\-(\w+)/,
        /linkedin\.com\/embed\/feed\/update\/urn:li:ugcPost:(\w+)/
      ],
      name: 'LinkedIn',
      icon: 'üíº',
      type: 'mixed'
    },
    soundcloud: {
      patterns: [
        /soundcloud\.com\/[\w-]+\/[\w-]+/
      ],
      name: 'SoundCloud',
      icon: 'üéß',
      type: 'audio'
    },
    twitter: {
      patterns: [
        /(?:twitter\.com|x\.com)\/\w+\/status\/(\d+)/
      ],
      name: 'Twitter/X',
      icon: 'üê¶',
      type: 'mixed'
    }
  };

  // Current detection state
  let currentPlatform = null;
  let detectedMediaType = null;

  // Enhanced Folder Management
  class FolderManager {
    constructor() {
      this.folders = [];
      this.currentFolder = 'root';
    }

    async createFolder(name, parentId = 'root') {
      if (!currentUser) throw new Error('Not authenticated');
      
      if (!name || name.trim() === '') {
        throw new Error('Folder name cannot be empty');
      }

      const existingFolder = this.folders.find(folder => 
        folder.name.toLowerCase() === name.toLowerCase() && 
        folder.parentId === parentId
      );

      if (existingFolder) {
        throw new Error(`Folder "${name}" already exists in this location`);
      }

      const folder = {
        id: `folder_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: name.trim(),
        parentId: parentId,
        path: await this.generateFolderPath(parentId, name.trim()),
        created: Date.now(),
        updated: Date.now(),
        itemCount: 0
      };

      await db.collection('users').doc(currentUser.uid).collection('folders').doc(folder.id).set(folder);
      this.folders.push(folder);
      
      return folder;
    }

    async generateFolderPath(parentId, folderName) {
      if (parentId === 'root') {
        return `/${folderName}`;
      }

      const parentFolder = this.folders.find(f => f.id === parentId);
      if (!parentFolder) {
        throw new Error('Parent folder not found');
      }

      return `${parentFolder.path}/${folderName}`;
    }

    async deleteFolder(folderId) {
      if (!currentUser) throw new Error('Not authenticated');
      
      const folder = this.folders.find(f => f.id === folderId);
      if (!folder) {
        throw new Error('Folder not found');
      }

      const subfolders = this.folders.filter(f => f.parentId === folderId);
      if (subfolders.length > 0) {
        throw new Error('Cannot delete folder that contains subfolders');
      }

      const folderMedia = Object.values(videosData).filter(item => item.folderId === folderId);
      if (folderMedia.length > 0) {
        const move = confirm(`Folder contains ${folderMedia.length} media items. Move them to Main Library before deleting?`);
        
        if (move) {
          for (const item of folderMedia) {
            await this.moveMediaToFolder(item.id, '');
          }
        } else {
          return;
        }
      }

      await db.collection('users').doc(currentUser.uid).collection('folders').doc(folderId).delete();
      this.folders = this.folders.filter(f => f.id !== folderId);
      
      if (this.currentFolder === folderId) {
        this.currentFolder = '';
      }
    }

    async renameFolder(folderId, newName) {
      if (!currentUser) throw new Error('Not authenticated');
      
      if (!newName || newName.trim() === '') {
        throw new Error('Folder name cannot be empty');
      }

      const folder = this.folders.find(f => f.id === folderId);
      if (!folder) {
        throw new Error('Folder not found');
      }

      const duplicate = this.folders.find(f => 
        f.name.toLowerCase() === newName.toLowerCase() && 
        f.parentId === folder.parentId &&
        f.id !== folderId
      );

      if (duplicate) {
        throw new Error(`Folder "${newName}" already exists in this location`);
      }

      folder.name = newName.trim();
      folder.updated = Date.now();
      folder.path = await this.generateFolderPath(folder.parentId, newName.trim());

      await db.collection('users').doc(currentUser.uid).collection('folders').doc(folderId).set(folder);
    }

    async moveMediaToFolder(mediaId, targetFolderId) {
      if (!currentUser) throw new Error('Not authenticated');
      
      const mediaItem = videosData[mediaId];
      if (!mediaItem) {
        throw new Error('Media item not found');
      }

      mediaItem.folderId = targetFolderId;
      mediaItem.lastModified = Date.now();

      await db.collection('users').doc(currentUser.uid).collection('videos').doc(mediaId).set(mediaItem);
    }

    getFolderTree(parentId = 'root', level = 0) {
      const children = this.folders.filter(folder => folder.parentId === parentId);
      
      return children.map(folder => ({
        ...folder,
        level: level,
        children: this.getFolderTree(folder.id, level + 1)
      }));
    }

    getFolderPath(folderId) {
      if (folderId === 'root' || !folderId) return 'Main Library';
      
      const folder = this.folders.find(f => f.id === folderId);
      return folder ? folder.path : 'Unknown Folder';
    }

    getMediaInFolder(folderId) {
      return Object.values(videosData).filter(item => item.folderId === folderId);
    }

    getFolderItemCount(folderId) {
      const directMedia = this.getMediaInFolder(folderId).length;
      const subfolders = this.folders.filter(f => f.parentId === folderId);
      const subfolderMedia = subfolders.reduce((count, subfolder) => 
        count + this.getFolderItemCount(subfolder.id), 0);
      
      return directMedia + subfolderMedia;
    }
  }

  // Initialize folder manager
  const folderManager = new FolderManager();

  // Export/Backup Implementation
  class ExportManager {
    constructor() {
      this.exportFormats = {
        json: 'JSON',
        csv: 'CSV',
        html: 'HTML'
      };
    }

    async exportLibrary(format = 'json') {
      if (!currentUser) throw new Error('Not authenticated');

      try {
        showNotification('Preparing export...', 'info');
        
        const exportData = {
          metadata: {
            version: '1.0',
            exportDate: new Date().toISOString(),
            itemCount: Object.keys(videosData).length,
            folderCount: folderManager.folders.length
          },
          folders: folderManager.folders,
          media: Object.values(videosData).map(item => ({
            ...item,
            url: undefined,
            storagePath: undefined
          }))
        };

        let content, mimeType, filename;

        switch (format) {
          case 'json':
            content = JSON.stringify(exportData, null, 2);
            mimeType = 'application/json';
            filename = `mediatracker-export-${Date.now()}.json`;
            break;

          case 'csv':
            content = this.convertToCSV(exportData);
            mimeType = 'text/csv';
            filename = `mediatracker-export-${Date.now()}.csv`;
            break;

          case 'html':
            content = this.convertToHTML(exportData);
            mimeType = 'text/html';
            filename = `mediatracker-export-${Date.now()}.html`;
            break;

          default:
            throw new Error('Unsupported export format');
        }

        this.downloadFile(content, mimeType, filename);
        showNotification(`Library exported as ${format.toUpperCase()}!`, 'success');

      } catch (error) {
        console.error('Export error:', error);
        showNotification(`Export failed: ${error.message}`, 'error');
      }
    }

    convertToCSV(data) {
      const headers = ['Name', 'Type', 'Size', 'Folder', 'Upload Date', 'Source'];
      const rows = data.media.map(item => [
        `"${item.name.replace(/"/g, '""')}"`,
        item.type,
        item.size,
        `"${folderManager.getFolderPath(item.folderId).replace(/"/g, '""')}"`,
        new Date(item.createdAt?.toDate() || item.uploadDate).toLocaleDateString(),
        item.source || 'Upload'
      ]);

      return [headers, ...rows].map(row => row.join(',')).join('\n');
    }

    convertToHTML(data) {
      return `
<!DOCTYPE html>
<html>
<head>
  <title>MediaTracker Export</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; margin: 20px 0; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    .summary { background: #f9f9f9; padding: 15px; border-radius: 5px; margin: 20px 0; }
  </style>
</head>
<body>
  <h1>MediaTracker Library Export</h1>
  <div class="summary">
    <p><strong>Export Date:</strong> ${new Date(data.metadata.exportDate).toLocaleString()}</p>
    <p><strong>Total Items:</strong> ${data.metadata.itemCount}</p>
    <p><strong>Total Folders:</strong> ${data.metadata.folderCount}</p>
  </div>
  
  <h2>Media Items</h2>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Size</th>
        <th>Folder</th>
        <th>Upload Date</th>
        <th>Source</th>
      </tr>
    </thead>
    <tbody>
      ${data.media.map(item => `
        <tr>
          <td>${item.name}</td>
          <td>${item.type}</td>
          <td>${formatFileSize(item.size)}</td>
          <td>${folderManager.getFolderPath(item.folderId)}</td>
          <td>${new Date(item.createdAt?.toDate() || item.uploadDate).toLocaleDateString()}</td>
          <td>${item.source || 'Upload'}</td>
        </tr>
      `).join('')}
    </tbody>
  </table>
</body>
</html>`;
    }

    downloadFile(content, mimeType, filename) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    async importLibrary(file) {
      if (!currentUser) throw new Error('Not authenticated');

      try {
        showNotification('Importing library...', 'info');
        
        const fileContent = await this.readFile(file);
        let importData;

        if (file.type === 'application/json') {
          importData = JSON.parse(fileContent);
        } else {
          throw new Error('Only JSON imports are currently supported');
        }

        if (!importData.folders || !importData.media) {
          throw new Error('Invalid import file format');
        }

        for (const folder of importData.folders) {
          try {
            await folderManager.createFolder(folder.name, folder.parentId);
          } catch (error) {
            console.warn('Folder import warning:', error.message);
          }
        }

        await loadUserData();
        showNotification('Library imported successfully!', 'success');

      } catch (error) {
        console.error('Import error:', error);
        showNotification(`Import failed: ${error.message}`, 'error');
      }
    }

    readFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    }
  }

  // Initialize export manager
  const exportManager = new ExportManager();

  // Show Notification
  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 8px;
      color: white;
      z-index: 10000;
      font-weight: 600;
      transition: all 0.3s ease;
      transform: translateX(100%);
    `;
    
    if (type === 'success') {
      notification.style.background = '#10b981';
    } else if (type === 'error') {
      notification.style.background = '#ef4444';
    } else {
      notification.style.background = '#7c3aed';
    }
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.style.transform = 'translateX(0)';
    }, 100);
    
    setTimeout(() => {
      notification.style.transform = 'translateX(100%)';
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 300);
    }, 3000);
  }

  // Initialize app
  function initApp() {
    console.log('Initializing app...');
    
    // Set initial state - show ONLY auth screen, COMPLETELY hide app
    showAuth();
    
    // Auth state observer
    auth.onAuthStateChanged((user) => {
      console.log('Auth state changed:', user);
      if (user) {
        currentUser = user;
        showApp();
        loadUserData();
      } else {
        showAuth();
      }
    });

    // Event listeners
    authForm.addEventListener('submit', handleAuth);
    signOutBtn.addEventListener('click', signOut);
    syncBtn.addEventListener('click', syncData);
    mobileSyncBtn.addEventListener('click', syncData);
    mobileAddBtn.addEventListener('click', () => fileInputVideo.click());
    searchInput.addEventListener('input', filterVideos);
    sortBtn.addEventListener('click', toggleSort);
    addFolderBtn.addEventListener('click', addFolder);
    newFolderName.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') addFolder();
    });
    
    // File input handlers
    fileInputVideo.addEventListener('change', handleFileUpload);
    fileInputPhoto.addEventListener('change', handleFileUpload);
    addVideoBtn.addEventListener('click', () => fileInputVideo.click());
    addPhotoBtn.addEventListener('click', () => fileInputPhoto.click());

    // Cloud storage dropdown
    cloudStorageBtn.addEventListener('click', toggleCloudStorageDropdown);
    fileToolsBtn.addEventListener('click', toggleFileToolsDropdown);

    // Video popup handlers
    closePopup.addEventListener('click', closeVideoPopup);
    
    // Close popup when clicking on overlay background
    videoPopup.addEventListener('click', (e) => {
      if (e.target === videoPopup) {
        closeVideoPopup();
      }
    });

    // Close popup with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && videoPopup.classList.contains('show')) {
        closeVideoPopup();
      }
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!cloudStorageBtn.contains(e.target) && !cloudStorageDropdown.contains(e.target)) {
        cloudStorageDropdown.classList.remove('show');
      }
      if (!fileToolsBtn.contains(e.target) && !fileToolsDropdown.contains(e.target)) {
        fileToolsDropdown.classList.remove('show');
      }
    });

    // Cloud storage option handlers
    document.querySelectorAll('.cloud-option').forEach(option => {
      option.addEventListener('click', () => {
        const provider = option.dataset.provider;
        if (provider === 'local') {
          importLocalFolder();
        } else {
          showCloudBrowser(provider);
        }
        cloudStorageDropdown.classList.remove('show');
      });
    });

    // File tools option handlers
    document.querySelectorAll('.file-tool-option').forEach(option => {
      option.addEventListener('click', () => {
        const tool = option.dataset.tool;
        showFileTool(tool);
      });
    });

    // Twitter Download Handler
    downloadUrlBtn.addEventListener('click', downloadFromTwitterUrl);

    // Multi-Platform Downloader Handlers
    detectMediaBtn.addEventListener('click', detectAndFetchMedia);
    clearUrlBtn.addEventListener('click', clearUrl);
    multiPlatformUrl.addEventListener('input', handleUrlInput);
    multiPlatformUrl.addEventListener('paste', handleUrlPaste);

    // Export/Import Handlers
    exportBtn.addEventListener('click', handleExport);
    importBtn.addEventListener('click', handleImport);

    // Local folder input handler
    localFolderInput.addEventListener('change', handleLocalFolderImport);

    // Document-level drag events for indicator
    document.addEventListener('dragover', handleDocumentDragOver);
    document.addEventListener('dragleave', handleDocumentDragLeave);
    document.addEventListener('drop', handleDocumentDrop);

    // Network status monitoring
    window.addEventListener('online', () => {
      isOnline = true;
      updateSyncStatus('syncing', 'Syncing...');
      if (currentUser) {
        loadUserData();
      }
    });

    window.addEventListener('offline', () => {
      isOnline = false;
      updateSyncStatus('error', 'Offline');
    });

    // Initialize multi-platform downloader
    initAutoDetection();
  }

  // Multi-Platform Downloader Functions
  function handleUrlInput() {
    const url = multiPlatformUrl.value.trim();
    if (url) {
      const detected = detectPlatform(url);
      if (detected) {
        showPlatformInfo(detected);
      } else {
        hidePlatformInfo();
      }
    } else {
      hidePlatformInfo();
    }
  }

  function handleUrlPaste(e) {
    setTimeout(() => {
      handleUrlInput();
    }, 100);
  }

  function clearUrl() {
    multiPlatformUrl.value = '';
    hidePlatformInfo();
    multiPlatformPreview.classList.remove('show');
    updateApiStatus('ready', 'Ready to detect media');
  }

  function detectPlatform(url) {
    for (const [platformId, platformData] of Object.entries(PLATFORM_PATTERNS)) {
      for (const pattern of platformData.patterns) {
        if (pattern.test(url)) {
          return {
            id: platformId,
            name: platformData.name,
            icon: platformData.icon,
            defaultType: platformData.type
          };
        }
      }
    }
    return null;
  }

  function showPlatformInfo(platform) {
    currentPlatform = platform;
    platformIcon.textContent = platform.icon;
    platformName.textContent = platform.name;
    mediaType.textContent = platform.defaultType === 'mixed' ? 'Media' : platform.defaultType;
    platformInfo.style.display = 'block';
  }

  function hidePlatformInfo() {
    currentPlatform = null;
    platformInfo.style.display = 'none';
  }

  async function detectAndFetchMedia() {
    const url = multiPlatformUrl.value.trim();
    
    if (!url) {
      alert('Please enter a URL');
      return;
    }

    const platform = detectPlatform(url);
    if (!platform) {
      alert('Unsupported platform or invalid URL. Supported: YouTube, Instagram, TikTok, Facebook, Reddit, Pinterest, Dailymotion, Vimeo, Twitch, LinkedIn, SoundCloud, Twitter/X');
      return;
    }

    try {
      updateApiStatus('syncing', `Detecting ${platform.name} media...`);
      detectMediaBtn.textContent = 'Detecting...';
      detectMediaBtn.disabled = true;
      multiPlatformPreview.classList.remove('show');

      const mediaData = await fetchMediaInfo(url, platform);
      displayMediaInfo(mediaData, platform);
      updateApiStatus('synced', `${platform.name} media detected`);

    } catch (error) {
      console.error('Error detecting media:', error);
      updateApiStatus('error', `Error: ${error.message}`);
      alert(`Error detecting media: ${error.message}`);
    } finally {
      detectMediaBtn.textContent = 'üîç Detect Media';
      detectMediaBtn.disabled = false;
    }
  }

  async function fetchMediaInfo(url, platform) {
    // Simple mock implementation - in a real app, you'd call actual APIs
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    return {
      title: `Sample ${platform.name} Media`,
      author: 'Demo Author',
      duration: '2:30',
      thumbnail: '',
      type: platform.defaultType,
      formats: [
        { quality: 'HD', url: '#' },
        { quality: 'SD', url: '#' }
      ]
    };
  }

  function displayMediaInfo(mediaData, platform) {
    multiPlatformPreview.classList.add('show');
    detectedMediaType = mediaData.type;
    
    // Hide all preview elements
    multiPlatformVideoPreview.style.display = 'none';
    multiPlatformImagePreview.style.display = 'none';
    multiPlatformAudioPreview.style.display = 'none';
    
    // Clear previous options
    multiPlatformDownloadOptions.innerHTML = '';

    // Display media information
    const infoText = [];
    if (mediaData.title) infoText.push(mediaData.title);
    if (mediaData.author) infoText.push(`by ${mediaData.author}`);
    if (mediaData.duration) infoText.push(`‚Ä¢ ${mediaData.duration}`);
    
    multiPlatformVideoInfo.textContent = infoText.join(' ');
    
    // Update media type badge
    mediaType.textContent = mediaData.type;
    mediaType.style.background = getMediaTypeColor(mediaData.type);

    // Show appropriate preview
    switch (mediaData.type) {
      case 'video':
        showVideoPreview(mediaData, platform);
        break;
      case 'image':
        showImagePreview(mediaData, platform);
        break;
      case 'audio':
        showAudioPreview(mediaData, platform);
        break;
      default:
        showFallbackPreview(mediaData, platform);
    }
    
    // Create download buttons
    createDownloadButtons(mediaData, platform);
  }

  function showVideoPreview(mediaData, platform) {
    if (mediaData.thumbnail) {
      multiPlatformVideoPreview.poster = mediaData.thumbnail;
    }
    multiPlatformVideoPreview.style.display = 'block';
  }

  function showImagePreview(mediaData, platform) {
    if (mediaData.thumbnail) {
      multiPlatformImagePreview.src = mediaData.thumbnail;
    }
    multiPlatformImagePreview.style.display = 'block';
  }

  function showAudioPreview(mediaData, platform) {
    multiPlatformAudioPreview.style.display = 'block';
  }

  function showFallbackPreview(mediaData, platform) {
    multiPlatformVideoInfo.textContent += ' ‚Ä¢ üìÅ File';
  }

  function getMediaTypeColor(type) {
    const colors = {
      video: '#7c3aed',
      image: '#10b981',
      audio: '#f59e0b',
      mixed: '#8b5cf6'
    };
    return colors[type] || '#6b7280';
  }

  function createDownloadButtons(mediaData, platform) {
    if (mediaData.formats && mediaData.formats.length > 0) {
      mediaData.formats.forEach((format, index) => {
        const button = createDownloadButton(format, mediaData, platform, index);
        multiPlatformDownloadOptions.appendChild(button);
      });
    } else {
      const button = createDownloadButton({
        quality: 'Download',
        url: mediaData.url || '#'
      }, mediaData, platform, 0);
      multiPlatformDownloadOptions.appendChild(button);
    }
  }

  function createDownloadButton(format, mediaData, platform, index) {
    const button = document.createElement('button');
    button.className = 'twitter-download-btn';
    
    const quality = format.quality || `Quality ${index + 1}`;
    const size = format.size ? ` (${format.size})` : '';
    
    button.textContent = `Download ${quality}${size}`;
    button.onclick = () => downloadMedia(
      format.url, 
      mediaData, 
      quality, 
      platform,
      detectedMediaType
    );
    
    return button;
  }

  async function downloadMedia(mediaUrl, mediaData, quality, platform, mediaType) {
    try {
      updateApiStatus('syncing', 'Downloading...');
      detectMediaBtn.textContent = 'Downloading...';
      detectMediaBtn.disabled = true;

      // Mock download - in real implementation, you'd fetch from the actual URL
      const blob = new Blob([''], { type: mediaType === 'video' ? 'video/mp4' : 'image/jpeg' });
      
      const safeTitle = mediaData.title ? 
        mediaData.title.replace(/[^a-z0-9]/gi, '_').substring(0, 50) : 
        `${platform.id}_media`;
      
      const fileExtension = getFileExtension(mediaType, mediaUrl);
      const filename = `${platform.id}_${safeTitle}_${quality}.${fileExtension}`;
      
      const savedData = await saveDownloadedMedia(
        blob, 
        filename, 
        mediaType, 
        mediaData, 
        platform, 
        quality
      );
      
      if (savedData) {
        addVideoToViewer(savedData);
      }
      
      updateApiStatus('synced', 'Download complete!');
      showNotification(`${mediaType} downloaded from ${platform.name}!`, 'success');
      
      setTimeout(() => {
        multiPlatformPreview.classList.remove('show');
        updateApiStatus('ready', 'Ready to detect media');
      }, 2000);
      
    } catch (error) {
      console.error('Error downloading media:', error);
      updateApiStatus('error', `Download failed: ${error.message}`);
      alert('Error downloading media: ' + error.message);
    } finally {
      detectMediaBtn.textContent = 'üîç Detect Media';
      detectMediaBtn.disabled = false;
    }
  }

  function getFileExtension(mediaType, url) {
    if (mediaType === 'video') return 'mp4';
    if (mediaType === 'image') return 'jpg';
    if (mediaType === 'audio') return 'mp3';
    
    const match = url.match(/\.([0-9a-z]+)(?:[\?#]|$)/i);
    return match ? match[1] : 'mp4';
  }

  async function saveDownloadedMedia(blob, filename, type, mediaData, platform, quality) {
    if (!currentUser) {
      alert('Please sign in first');
      return null;
    }

    try {
      const storageRef = storage.ref().child(`users/${currentUser.uid}/downloaded/${filename}`);
      const snapshot = await storageRef.put(blob);
      const downloadURL = await snapshot.ref.getDownloadURL();
      
      const mediaDoc = {
        name: filename,
        url: downloadURL,
        type: type,
        size: blob.size,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        folderId: currentFolder || '',
        source: 'downloaded',
        platformData: {
          originalPlatform: platform.id,
          title: mediaData.title,
          author: mediaData.author,
          quality: quality,
          originalUrl: multiPlatformUrl.value,
          duration: mediaData.duration,
          thumbnail: mediaData.thumbnail
        }
      };
      
      const docRef = await db.collection('users').doc(currentUser.uid).collection('videos').add(mediaDoc);
      mediaDoc.id = docRef.id;
      
      loadUserData();
      
      return mediaDoc;
      
    } catch (error) {
      console.error('Error saving to storage:', error);
      throw new Error('Failed to save media to storage');
    }
  }

  function updateApiStatus(status, text) {
    apiIndicator.className = 'sync-indicator ' + status;
    apiStatusText.textContent = text;
  }

  function initAutoDetection() {
    console.log('Multi-platform auto-detection initialized');
    updateApiStatus('ready', 'Ready to detect media');
  }

  // Auth functions
  function handleAuth(e) {
    e.preventDefault();
    const email = authEmail.value;
    const password = authPassword.value;
    
    showAuthLoading(true);
    authError.style.display = 'none';
    
    auth.signInWithEmailAndPassword(email, password)
      .then((userCredential) => {
        currentUser = userCredential.user;
        showApp();
        loadUserData();
      })
      .catch((error) => {
        showAuthError(error.message);
      })
      .finally(() => {
        showAuthLoading(false);
      });
  }

  function signOut() {
    auth.signOut();
  }

  function showAuth() {
    console.log('Showing auth screen');
    authScreen.style.display = 'flex';
    authScreen.classList.remove('authenticated');
    appContainer.style.display = 'none';
    appContainer.classList.remove('authenticated');
  }

  function showApp() {
    console.log('Showing app screen');
    authScreen.style.display = 'none';
    authScreen.classList.add('authenticated');
    appContainer.style.display = 'block';
    appContainer.classList.add('authenticated');
  }

  function showAuthError(message) {
    authError.textContent = message;
    authError.style.display = 'block';
  }

  function showAuthLoading(show) {
    authLoading.style.display = show ? 'block' : 'none';
    authSubmit.disabled = show;
  }

  // Data management
  function loadUserData() {
    if (!currentUser) return;
    
    // Load folders
    db.collection('users').doc(currentUser.uid).collection('folders')
      .onSnapshot((snapshot) => {
        folderManager.folders = [];
        snapshot.forEach((doc) => {
          folderManager.folders.push({ id: doc.id, ...doc.data() });
        });
        renderFolders();
        updateParentFolderSelect();
      });

    // Load videos
    db.collection('users').doc(currentUser.uid).collection('videos')
      .onSnapshot((snapshot) => {
        videosData = {};
        snapshot.forEach((doc) => {
          videosData[doc.id] = { id: doc.id, ...doc.data() };
        });
        renderVideos();
      });
  }

  function syncData() {
    updateSyncStatus('syncing', 'Syncing...');
    setTimeout(() => {
      updateSyncStatus('synced', 'Synced just now');
      setTimeout(() => {
        updateSyncStatus('ready', 'Ready to sync');
      }, 2000);
    }, 1000);
  }

  function updateSyncStatus(status, text) {
    syncIndicator.className = 'sync-indicator ' + status;
    syncStatusText.textContent = text;
  }

  // Folder functions
  function addFolder() {
    const name = newFolderName.value.trim();
    const parentFolderId = parentFolderSelect.value || 'root';
    
    if (!name) {
      alert('Please enter a folder name');
      return;
    }
    
    folderManager.createFolder(name, parentFolderId)
      .then(() => {
        newFolderName.value = '';
        parentFolderSelect.value = '';
      })
      .catch((error) => {
        console.error('Error adding folder:', error);
        alert('Error creating folder: ' + error.message);
      });
  }

  function updateParentFolderSelect() {
    parentFolderSelect.innerHTML = '<option value="">üè† Main Library (Home)</option>';
    
    function addFolderOptions(folders, level = 0) {
      folders.forEach(folder => {
        const indent = '‚îÄ '.repeat(level);
        const option = document.createElement('option');
        option.value = folder.id;
        option.textContent = `${indent} ${folder.name}`;
        parentFolderSelect.appendChild(option);
        
        const children = folderManager.folders.filter(f => f.parentId === folder.id);
        if (children.length > 0) {
          addFolderOptions(children, level + 1);
        }
      });
    }
    
    const rootFolders = folderManager.folders.filter(f => !f.parentId || f.parentId === 'root');
    addFolderOptions(rootFolders);
  }

  function renderFolders() {
    folders.innerHTML = '';
    
    const folderTree = folderManager.getFolderTree();
    
    if (folderTree.length === 0) {
      folders.innerHTML = '<div style="text-align:center;padding:20px;color:var(--muted)">No folders yet. Create one above!</div>';
      return;
    }
    
    renderFolderTree(folderTree, folders);
  }

  function renderFolderTree(folderTree, container, level = 0) {
    folderTree.forEach(folder => {
      const folderElement = document.createElement('div');
      folderElement.className = 'folder-item' + (currentFolder === folder.id ? ' active' : '');
      folderElement.style.paddingLeft = (level * 20) + 'px';
      folderElement.setAttribute('data-folder-id', folder.id);
      
      folderElement.innerHTML = `
        <span>üìÅ</span>
        <div class="name">${folder.name}</div>
        <div class="count">${folderManager.getFolderItemCount(folder.id)}</div>
        <div class="folder-actions-menu">
          <button class="folder-action-btn" onclick="event.stopPropagation(); addSubfolder('${folder.id}')" title="Add subfolder">‚ûï</button>
          <button class="folder-action-btn" onclick="event.stopPropagation(); renameFolder('${folder.id}')" title="Rename">‚úèÔ∏è</button>
          <button class="folder-delete-btn" onclick="event.stopPropagation(); deleteFolder('${folder.id}', '${folder.name.replace(/'/g, "\\'")}')" title="Delete folder">üóëÔ∏è</button>
        </div>
      `;
      
      folderElement.addEventListener('click', () => selectFolder(folder.id));
      container.appendChild(folderElement);
      
      if (folder.children && folder.children.length > 0) {
        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'folder-children';
        container.appendChild(childrenContainer);
        renderFolderTree(folder.children, childrenContainer, level + 1);
      }
    });
  }

  // Enhanced folder functions
  async function renameFolder(folderId) {
    const folder = folderManager.folders.find(f => f.id === folderId);
    if (!folder) return;

    const newName = prompt('Enter new folder name:', folder.name);
    if (!newName || newName.trim() === '') return;

    try {
      await folderManager.renameFolder(folderId, newName.trim());
      renderFolders();
      updateParentFolderSelect();
      showNotification(`Folder renamed to "${newName}"!`, 'success');
    } catch (error) {
      showNotification(error.message, 'error');
    }
  }

  async function deleteFolder(folderId, folderName) {
    try {
      await folderManager.deleteFolder(folderId);
      renderFolders();
      updateParentFolderSelect();
      showNotification(`Folder "${folderName}" deleted successfully!`, 'success');
    } catch (error) {
      showNotification(error.message, 'error');
    }
  }

  function addSubfolder(parentFolderId) {
    const folderName = prompt('Enter subfolder name:');
    if (folderName && folderName.trim()) {
      folderManager.createFolder(folderName.trim(), parentFolderId)
        .catch((error) => {
          console.error('Error adding subfolder:', error);
          alert('Error creating subfolder: ' + error.message);
        });
    }
  }

  function selectFolder(folderId) {
    currentFolder = folderId;
    renderVideos();
    
    document.querySelectorAll('.folder-item').forEach(f => f.classList.remove('active'));
    document.querySelector(`.folder-item[data-folder-id="${folderId}"]`)?.classList.add('active');
  }

  // Video functions
  function renderVideos() {
    videoList.innerHTML = '';
    
    if (Object.keys(videosData).length === 0) {
      videoList.innerHTML = '<div style="text-align:center;padding:20px;color:var(--muted)">No media yet. Add some videos or photos to get started!</div>';
      return;
    }
    
    let videosArray = Object.values(videosData);
    
    if (currentFolder) {
      videosArray = videosArray.filter(video => video.folderId === currentFolder);
    }
    
    const searchTerm = searchInput.value.toLowerCase();
    if (searchTerm) {
      videosArray = videosArray.filter(video => 
        video.name.toLowerCase().includes(searchTerm) ||
        (video.tags && video.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
      );
    }
    
    videosArray.sort((a, b) => {
      if (sortOrder === 'newest') {
        return (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0);
      } else {
        return (a.createdAt?.toDate() || 0) - (b.createdAt?.toDate() || 0);
      }
    });
    
    videosArray.forEach(video => {
      const videoElement = document.createElement('div');
      videoElement.className = 'vitem';
      videoElement.setAttribute('data-video-id', video.id);
      videoElement.innerHTML = `
        <div class="thumb">
          ${video.thumbnailUrl ? `<img src="${video.thumbnailUrl}" alt="${video.name}" loading="lazy">` : 
            video.type === 'photo' ? 'üñºÔ∏è' : 'üìπ'}
        </div>
        <div class="meta">
          <h3>${video.name}</h3>
          <p>${formatFileSize(video.size)} ‚Ä¢ ${video.duration || '0:00'} ‚Ä¢ ${formatDate(video.createdAt?.toDate())}</p>
          <div class="small">
            ${video.tags ? video.tags.map(tag => `#${tag}`).join(' ') : ''}
            ${video.source === 'twitter' ? 'üê¶ Twitter' : video.source === 'url' ? 'üîó URL' : video.source === 'downloaded' ? 'üåê Downloaded' : ''}
          </div>
        </div>
        <div class="media-type-badge ${video.type === 'photo' ? 'media-type-photo' : 'media-type-video'}">
          ${video.type === 'photo' ? 'üì∑' : 'üé•'}
        </div>
      `;
      
      videoElement.addEventListener('click', () => playVideo(video));
      videoList.appendChild(videoElement);
    });
    
    // Re-initialize drag and drop after rendering
    setTimeout(initDragAndDrop, 100);
  }

  function playVideo(video) {
    if (video.type === 'video') {
      openVideoPopup(video);
    } else {
      alert(`Photo: ${video.name}\nURL: ${video.url}`);
    }
  }

  // Video Popup Functions
  function openVideoPopup(video) {
    console.log('Opening video popup for:', video.name);
    console.log('Video URL:', video.url);
    
    popupVideo.src = '';
    popupVideo.src = video.url;
    
    if (video.thumbnailUrl) {
      popupVideo.poster = video.thumbnailUrl;
    }
    
    popupVideo.setAttribute('playsinline', '');
    videoPopup.classList.add('show');
    document.body.classList.add('popup-open');
    
    const playPromise = popupVideo.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        console.log('Auto-play prevented:', error);
      });
    }
  }

  function closeVideoPopup() {
    popupVideo.pause();
    popupVideo.src = '';
    videoPopup.classList.remove('show');
    document.body.classList.remove('popup-open');
  }

  function filterVideos() {
    renderVideos();
  }

  function toggleSort() {
    sortOrder = sortOrder === 'newest' ? 'oldest' : 'newest';
    sortBtn.textContent = `üìÖ Sort: ${sortOrder === 'newest' ? 'Newest' : 'Oldest'}`;
    renderVideos();
  }

  // File upload
  function handleFileUpload(e) {
    const files = Array.from(e.target.files);
    const isPhoto = e.target === fileInputPhoto;
    
    files.forEach(file => {
      uploadFile(file, isPhoto ? 'photo' : 'video');
    });
    
    e.target.value = '';
  }

  function uploadFile(file, type) {
    if (!currentUser) return;
    
    const fileId = Date.now().toString();
    const filePath = `users/${currentUser.uid}/${type}s/${fileId}_${file.name}`;
    const uploadTask = storage.ref(filePath).put(file);
    
    const videoData = {
      name: file.name,
      size: file.size,
      type: type,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      folderId: currentFolder,
      uploadProgress: 0
    };
    
    // Add to local data immediately
    videosData[fileId] = { ...videoData, id: fileId };
    renderVideos();
    
    db.collection('users').doc(currentUser.uid).collection('videos').doc(fileId).set(videoData);
    
    uploadTask.on('state_changed',
      (snapshot) => {
        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
        db.collection('users').doc(currentUser.uid).collection('videos').doc(fileId).update({
          uploadProgress: progress
        });
      },
      (error) => {
        console.error('Upload error:', error);
        // Remove from local data on error
        delete videosData[fileId];
        renderVideos();
      },
      () => {
        uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
          const updatedData = {
            url: downloadURL,
            uploadProgress: 100
          };
          
          db.collection('users').doc(currentUser.uid).collection('videos').doc(fileId).update(updatedData);
          
          // Update local data
          videosData[fileId] = { ...videosData[fileId], ...updatedData };
          renderVideos();
          
          // Auto-play if it's a video
          if (type === 'video') {
            setTimeout(() => {
              playVideo(videosData[fileId]);
            }, 1000);
          }
        });
      }
    );
  }

  // Utility functions
  function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  function formatDate(date) {
    if (!date) return 'Unknown date';
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  }

  // Cloud Storage Functions
  function toggleCloudStorageDropdown() {
    cloudStorageDropdown.classList.toggle('show');
  }

  function toggleFileToolsDropdown() {
    fileToolsDropdown.classList.toggle('show');
  }

  function showCloudBrowser(provider) {
    alert(`Cloud browser for ${provider} would open here. This is a premium feature.`);
  }

  function showFileTool(tool) {
    alert(`File tool ${tool} would open here. This is a premium feature.`);
  }

  // Twitter Downloader Functions
  async function downloadFromTwitterUrl() {
    const url = videoUrl.value.trim();
    if (!url) {
      alert('Please enter a Twitter/X URL');
      return;
    }

    const tweetId = getTweetIdFromUrl(url);
    if (!tweetId) {
      alert('Please enter a valid Twitter/X URL');
      return;
    }

    try {
      downloadUrlBtn.textContent = 'Fetching...';
      downloadUrlBtn.disabled = true;
      twitterPreview.classList.remove('show');

      const apiUrl = `https://api.fxtwitter.com/status/${tweetId}`;
      const response = await fetch(apiUrl);
      
      if (!response.ok) {
        throw new Error('Failed to fetch tweet data');
      }

      const data = await response.json();
      
      if (!data || !data.tweet) {
        throw new Error('Invalid tweet data received');
      }

      displayTwitterMedia(data.tweet);

    } catch (error) {
      console.error('Error fetching Twitter media:', error);
      alert('Error fetching media: ' + error.message);
    } finally {
      downloadUrlBtn.textContent = 'Fetch Twitter Media';
      downloadUrlBtn.disabled = false;
    }
  }

  function getTweetIdFromUrl(url) {
    const match = url.match(/twitter\.com\/\w+\/status\/(\d+)/) || 
                 url.match(/x\.com\/\w+\/status\/(\d+)/);
    return match ? match[1] : null;
  }

  function displayTwitterMedia(tweet) {
    twitterPreview.classList.add('show');
    twitterVideoInfo.textContent = `Tweet by ${tweet.author.name} (@${tweet.author.screen_name})`;
    
    // Clear previous options
    twitterDownloadOptions.innerHTML = '';

    if (tweet.media && tweet.media.videos) {
      const videos = tweet.media.videos;
      
      // Find the highest quality video for preview
      const highestQuality = videos.reduce((prev, current) => 
        (prev.bitrate > current.bitrate) ? prev : current
      );

      // Set video preview
      twitterVideoPreview.src = highestQuality.url;
      twitterVideoPreview.style.display = 'block';
      
      // Create download buttons for all available qualities
      videos.forEach(video => {
        const qualityLabel = getQualityLabel(video.bitrate, video.type);
        const button = document.createElement('button');
        button.className = 'twitter-download-btn';
        button.textContent = `Download ${qualityLabel} Quality`;
        button.onclick = () => downloadTwitterVideo(video.url, tweet, qualityLabel);
        twitterDownloadOptions.appendChild(button);
      });
    } else if (tweet.media && tweet.media.photos) {
      // Handle photos
      twitterVideoPreview.style.display = 'none';
      twitterVideoInfo.textContent += ' - Photo tweet';
      
      tweet.media.photos.forEach((photo, index) => {
        const button = document.createElement('button');
        button.className = 'twitter-download-btn';
        button.textContent = `Download Photo ${index + 1}`;
        button.onclick = () => downloadTwitterPhoto(photo.url, tweet, index);
        twitterDownloadOptions.appendChild(button);
      });
    } else {
      twitterPreview.classList.remove('show');
      alert('No media found in this tweet');
    }
  }

  function getQualityLabel(bitrate, type) {
    if (bitrate > 2000000) return 'HD';
    if (bitrate > 1000000) return 'Medium';
    return 'Standard';
  }

  async function downloadTwitterVideo(videoUrl, tweet, quality) {
    try {
      downloadUrlBtn.textContent = 'Downloading...';
      downloadUrlBtn.disabled = true;

      const response = await fetch(videoUrl);
      const blob = await response.blob();
      
      // Create a filename
      const filename = `twitter_${tweet.author.screen_name}_${tweet.id}_${quality}.mp4`;
      
      // Save to Firebase Storage and Firestore
      const videoData = await saveMediaToStorage(blob, filename, 'video', tweet, quality);
      
      // Add to video viewer immediately
      if (videoData) {
        addVideoToViewer(videoData);
      }
      
      alert('Video downloaded successfully!');
      twitterPreview.classList.remove('show');
      videoUrl.value = '';
    } catch (error) {
      console.error('Error downloading video:', error);
      alert('Error downloading video: ' + error.message);
    } finally {
      downloadUrlBtn.textContent = 'Fetch Twitter Media';
      downloadUrlBtn.disabled = false;
    }
  }

  async function downloadTwitterPhoto(photoUrl, tweet, index) {
    try {
      downloadUrlBtn.textContent = 'Downloading...';
      downloadUrlBtn.disabled = true;

      const response = await fetch(photoUrl);
      const blob = await response.blob();
      
      // Create a filename
      const filename = `twitter_${tweet.author.screen_name}_${tweet.id}_photo_${index + 1}.jpg`;
      
      // Save to Firebase Storage and Firestore
      const photoData = await saveMediaToStorage(blob, filename, 'photo', tweet, 'photo');
      
      // Add to video viewer immediately
      if (photoData) {
        addVideoToViewer(photoData);
      }
      
      alert('Photo downloaded successfully!');
      twitterPreview.classList.remove('show');
      videoUrl.value = '';
    } catch (error) {
      console.error('Error downloading photo:', error);
      alert('Error downloading photo: ' + error.message);
    } finally {
      downloadUrlBtn.textContent = 'Fetch Twitter Media';
      downloadUrlBtn.disabled = false;
    }
  }

  async function saveMediaToStorage(blob, filename, type, tweet, quality) {
    if (!currentUser) {
      alert('Please sign in first');
      return null;
    }

    // Create storage reference
    const storageRef = storage.ref().child(`users/${currentUser.uid}/media/${filename}`);
    
    // Upload file
    const snapshot = await storageRef.put(blob);
    const downloadURL = await snapshot.ref.getDownloadURL();
    
    // Create video data
    const videoData = {
      name: filename,
      url: downloadURL,
      type: type,
      size: blob.size,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      folderId: currentFolder || '',
      source: 'twitter',
      tweetData: {
        author: tweet.author.name,
        username: tweet.author.screen_name,
        tweetId: tweet.id,
        text: tweet.text,
        quality: quality
      }
    };
    
    // Add to Firestore
    const docRef = await db.collection('users').doc(currentUser.uid).collection('videos').add(videoData);
    videoData.id = docRef.id;
    
    // Refresh the media list
    loadUserData();
    
    return videoData;
  }

  function addVideoToViewer(videoData) {
    // Add to videosData immediately
    videosData[videoData.id] = videoData;
    
    // Render the video in the list
    renderVideos();
    
    // Auto-play if it's a video
    if (videoData.type === 'video') {
      setTimeout(() => {
        playVideo(videoData);
      }, 500);
    }
  }

  // Local Folder Import Functions
  function importLocalFolder() {
    localFolderInput.click();
  }

  function handleLocalFolderImport(e) {
    const files = Array.from(e.target.files);
    const mediaFiles = files.filter(file => 
      file.type.startsWith('video/') || file.type.startsWith('image/')
    );

    if (mediaFiles.length === 0) {
      alert('No media files found in the selected folder. Please select a folder containing videos or images.');
      return;
    }

    if (!confirm(`Found ${mediaFiles.length} media files. Upload them to your library?`)) {
      return;
    }

    let uploadedCount = 0;
    const totalFiles = mediaFiles.length;

    mediaFiles.forEach((file, index) => {
      setTimeout(() => {
        uploadFile(file, file.type.startsWith('video/') ? 'video' : 'photo');
        uploadedCount++;
        
        if (uploadedCount === totalFiles) {
          setTimeout(() => {
            alert(`Successfully uploaded ${uploadedCount} files from the folder!`);
          }, 1000);
        }
      }, index * 500);
    });

    // Reset the input
    e.target.value = '';
  }

  // Drag and Drop Functions
  function initDragAndDrop() {
    const videoItems = document.querySelectorAll('.vitem');
    const folderItems = document.querySelectorAll('.folder-item');
    
    // Make video items draggable
    videoItems.forEach(item => {
      item.setAttribute('draggable', 'true');
      item.addEventListener('dragstart', handleDragStart);
      item.addEventListener('dragend', handleDragEnd);
    });
    
    // Make folders drop targets
    folderItems.forEach(item => {
      item.addEventListener('dragover', handleDragOver);
      item.addEventListener('dragenter', handleDragEnter);
      item.addEventListener('dragleave', handleDragLeave);
      item.addEventListener('drop', handleDrop);
    });
  }

  function handleDragStart(e) {
    draggedVideo = e.target.closest('.vitem');
    e.dataTransfer.setData('text/plain', draggedVideo.dataset.videoId || '');
    e.dataTransfer.effectAllowed = 'move';
    
    draggedVideo.classList.add('dragging');
    
    // Show drag indicator
    dragIndicator.style.display = 'block';
    updateDragIndicatorPosition(e);
  }

  function handleDragEnd(e) {
    if (draggedVideo) {
      draggedVideo.classList.remove('dragging');
      draggedVideo = null;
    }
    dragIndicator.style.display = 'none';
    
    // Remove all drag-over classes
    document.querySelectorAll('.vitem.drag-over, .folder-item.drag-over').forEach(el => {
      el.classList.remove('drag-over');
    });
  }

  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  }

  function handleDragEnter(e) {
    e.preventDefault();
    const target = e.target.closest('.folder-item') || e.target.closest('.vitem');
    if (target && target !== draggedVideo) {
      target.classList.add('drag-over');
    }
  }

  function handleDragLeave(e) {
    const target = e.target.closest('.folder-item') || e.target.closest('.vitem');
    if (target) {
      target.classList.remove('drag-over');
    }
  }

  function handleDrop(e) {
    e.preventDefault();
    
    const targetFolder = e.target.closest('.folder-item');
    const targetVideo = e.target.closest('.vitem');
    
    if (targetFolder && draggedVideo) {
      const folderId = targetFolder.dataset.folderId;
      const videoId = draggedVideo.dataset.videoId;
      
      if (folderId && videoId) {
        moveVideoToFolder(videoId, folderId);
      }
    } else if (targetVideo && draggedVideo) {
      // Handle reordering if needed
      console.log('Reordering videos');
    }
    
    // Clean up
    handleDragEnd(e);
  }

  function handleDocumentDragOver(e) {
    e.preventDefault();
    updateDragIndicatorPosition(e);
  }

  function handleDocumentDragLeave(e) {
    if (!e.relatedTarget || e.relatedTarget.nodeName === 'HTML') {
      dragIndicator.style.display = 'none';
    }
  }

  function handleDocumentDrop(e) {
    e.preventDefault();
    dragIndicator.style.display = 'none';
  }

  function updateDragIndicatorPosition(e) {
    dragIndicator.style.left = (e.clientX + 10) + 'px';
    dragIndicator.style.top = (e.clientY + 10) + 'px';
  }

  function moveVideoToFolder(videoId, folderId) {
    if (!currentUser) return;
    
    db.collection('users').doc(currentUser.uid).collection('videos').doc(videoId).update({
      folderId: folderId
    }).then(() => {
      console.log(`Video ${videoId} moved to folder ${folderId}`);
      // Update folder item count
      updateFolderItemCount(folderId);
    }).catch(error => {
      console.error('Error moving video:', error);
      alert('Error moving video: ' + error.message);
    });
  }

  function updateFolderItemCount(folderId) {
    // Count videos in this folder
    const videosInFolder = Object.values(videosData).filter(video => video.folderId === folderId);
    
    db.collection('users').doc(currentUser.uid).collection('folders').doc(folderId).update({
      itemCount: videosInFolder.length
    });
  }

  // Export Handler
  async function handleExport() {
    const format = prompt('Choose export format (json, csv, html):', 'json');
    if (format && exportManager.exportFormats[format.toLowerCase()]) {
      await exportManager.exportLibrary(format.toLowerCase());
    } else {
      showNotification('Invalid export format', 'error');
    }
  }

  // Import Handler
  function handleImport() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (file) {
        exportManager.importLibrary(file);
      }
    };
    input.click();
  }

  // Initialize the app when DOM is loaded
  document.addEventListener('DOMContentLoaded', initApp);
</script>
</body>
</html>